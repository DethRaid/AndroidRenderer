#version 460

/**
 * Test NDC triangles against the min/max of each bin
 */

#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_basic : enable

#include "shared/vertex_data.hpp"
#include "shared/triangle.hpp"

layout(set = 0, binding = 0, std430) readonly buffer VertexOutputPositionBuffer {
    Triangle triangles[];
}; 

layout(set = 0, binding = 1, std430) readonly buffer TriangleBinsBuffer {
    uint bins[];
};

layout(set = 0, binding = 2, rgba16f) uniform image3D voxels;

layout(push_constant) uniform Constants {
    uint num_triangles;
    uint padding1;
    uint padding2;
    uint padding3;
    uint padding4;
    uint padding5;
    uint padding6;
    uint padding7;
};

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#define UINTS_PER_BIN (32768 / 32)

bool is_triangle_in_bin(Triangle triangle, vec3 voxel_min, vec3 voxel_max) {
    // Adapted from https://developer.nvidia.com/content/basics-gpu-voxelization

    vec3 aabb_max = max(triangle.v0, max(triangle.v1, triangle.v2));
    vec3 aabb_min = min(triangle.v0, min(triangle.v1, triangle.v2));

    // If the triangle's AABB doesn't overlap the bin's AABB, return false
    if(all(greaterThan(aabb_min, voxel_max)) || all(lessThan(aabb_max, voxel_min))) {
        return false;
    }

    vec3 voxelCenter = (voxel_min + voxel_max) * 0.5f;
    float voxelExtentH = voxel_max.x - voxel_min.x;

    //calculate edge vectors in voxel coordinate space
    vec3 e0 = triangle.v1 - triangle.v0;
    vec3 e1 = triangle.v2 - triangle.v1;
    vec3 e2 = triangle.v0 - triangle.v2;
    vec3 planeNormal = cross(e0, e1);

    // for testing in XY plane projection
    {
        float isFront = -sign(planeNormal.z);

        vec2 eNrm[3];
        eNrm[0] = vec2(e0.y, -e0.x) * isFront;
        eNrm[1] = vec2(e1.y, -e1.x) * isFront;
        eNrm[2] = vec2(e2.y, -e2.x) * isFront;

        vec2      an[3];
        an[0] = abs(eNrm[0]);
        an[1] = abs(eNrm[1]);
        an[2] = abs(eNrm[2]);

        // calculate signed distance offset from a voxel center

        // to the voxel vertex which has maximum signed

        // distance value.
        vec3      eOfs;
        eOfs.x = (an[0].x + an[0].y) * voxelExtentH;
        eOfs.y = (an[1].x + an[1].y) * voxelExtentH;
        eOfs.z = (an[2].x + an[2].y) * voxelExtentH;

        // calculate signed distance of each edges.
        vec3      ef;
        ef.x = eOfs.x - dot(triangle.v0.xy - voxelCenter.xy , eNrm[0]);
        ef.y = eOfs.y - dot(triangle.v1.xy - voxelCenter.xy , eNrm[1]);
        ef.z = eOfs.z - dot(triangle.v2.xy - voxelCenter.xy , eNrm[2]);

        // test is passed if all of signed distances are positive.
        if (ef.x < 0 || ef.y < 0 || ef.z < 0) {
            return false;
        }
    }
    // for testing in YZ plane projection
    {
        float isFront = -sign(planeNormal.x);

        vec2 eNrm[3];
        eNrm[0] = vec2(e0.z, -e0.y) * isFront;
        eNrm[1] = vec2(e1.z, -e1.y) * isFront;
        eNrm[2] = vec2(e2.z, -e2.y) * isFront;

        vec2      an[3];
        an[0] = abs(eNrm[0]);
        an[1] = abs(eNrm[1]);
        an[2] = abs(eNrm[2]);

        // calculate signed distance offset from a voxel center

        // to the voxel vertex which has maximum signed

        // distance value.
        vec3      eOfs;
        eOfs.x = (an[0].x + an[0].y) * voxelExtentH;
        eOfs.y = (an[1].x + an[1].y) * voxelExtentH;
        eOfs.z = (an[2].x + an[2].y) * voxelExtentH;

        // calculate signed distance of each edges.
        vec3      ef;
        ef.x = eOfs.x - dot(triangle.v0.yz - voxelCenter.yz , eNrm[0]);
        ef.y = eOfs.y - dot(triangle.v1.yz - voxelCenter.yz , eNrm[1]);
        ef.z = eOfs.z - dot(triangle.v2.yz - voxelCenter.yz , eNrm[2]);

        // test is passed if all of signed distances are positive.
        if (ef.x < 0 || ef.y < 0 || ef.z < 0) {
            return false;
        }
    }
    // for testing in XZ plane projection
    {
        float isFront = -sign(planeNormal.y);

        vec2 eNrm[3];
        eNrm[0] = vec2(e0.z, -e0.x) * isFront;
        eNrm[1] = vec2(e1.z, -e1.x) * isFront;
        eNrm[2] = vec2(e2.z, -e2.x) * isFront;

        vec2      an[3];
        an[0] = abs(eNrm[0]);
        an[1] = abs(eNrm[1]);
        an[2] = abs(eNrm[2]);

        // calculate signed distance offset from a voxel center

        // to the voxel vertex which has maximum signed

        // distance value.
        vec3      eOfs;
        eOfs.x = (an[0].x + an[0].y) * voxelExtentH;
        eOfs.y = (an[1].x + an[1].y) * voxelExtentH;
        eOfs.z = (an[2].x + an[2].y) * voxelExtentH;

        // calculate signed distance of each edges.
        vec3      ef;
        ef.x = eOfs.x - dot(triangle.v0.xz - voxelCenter.xz , eNrm[0]);
        ef.y = eOfs.y - dot(triangle.v1.xz - voxelCenter.xz , eNrm[1]);
        ef.z = eOfs.z - dot(triangle.v2.xz - voxelCenter.xz , eNrm[2]);

        // test is passed if all of signed distances are positive.
        if (ef.x < 0 || ef.y < 0 || ef.z < 0) {
            return false;
        }
    }

    // Otherwise return true
    return true;
}

void main() {
    // Setup phase - set 1/32 of the bin bits to 0

    uint local_index = gl_SubgroupInvocationID + gl_SubgroupID * gl_SubgroupSize;

    // Each bin is 4x4x4 pixels
    uvec3 bin_idx = gl_WorkGroupID;
    // 4x4x4 bins in a 32x32x32 image - 8 bins in all directions
    vec3 bin_min = vec3(bin_idx) / 8.f;
    vec3 bin_max = bin_min + (1.f / 8.f);

    // Each thread takes all the triangles in this bin, tests them against its current pixel, and adds their SHes to an
    // accumulator. We flush the accumulator to the image at the end - each thread only reads and writes to its pixel, 
    // so no atomic operations are needed (yayyyyyyyy)

    // Load into shared memory or something
    vec4 sh = imageLoad(voxels, ivec3(gl_GlobalInvocationID));

    // TODO: Each thread should only load one triangle. It should test it against each cell in the bin, and push its SH
    // to any cell that it intersects

    // TODO: Store the triangle's bounding box and SH projection separately

    vec3 cell_min = bin_min + vec3(gl_LocalInvocationID) * 0.25f;
    vec3 cell_max = bin_max + vec3(gl_LocalInvocationID) * 0.25f;

    uint bin_range_start = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;

    // Add triangles as needed
    // Each thread is gonna have to load every triangle that's in the bin... maybe we could share them better?
    for(uint i = 0; i < UINTS_PER_BIN; i++) {
        uint current_bin_bits = bins[bin_range_start + i];

        while(current_bin_bits > 0) {
            int bit = findLSB(current_bin_bits);
            current_bin_bits &= ~uint(1 << bit);
           
            // The triangle is in this bin
            // Might be more efficient for each thread in the workgroup to pull a different triangle, test it 
            // against all cells in the bin, then broadcast it to the threads for any cells it's in?
            // If each thread tests every triangle against every bin, we run in about 20 ms per frame
            uint triangle_index = i * 32 + bit;
            Triangle triangle = triangles[triangle_index];
            if(is_triangle_in_bin(triangle, cell_min, cell_max)) {
                sh += triangle.normal_sh;
            }
        }
    }

    float sh_length = length(sh);
    if(sh_length > 0) {
        sh /= sh_length;
    }

    imageStore(voxels, ivec3(gl_GlobalInvocationID), sh);
}
