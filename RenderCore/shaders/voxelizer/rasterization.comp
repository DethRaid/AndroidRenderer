#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_basic : enable

#include "shared/vertex_data.hpp"
#include "shared/triangle.hpp"

layout(set = 0, binding = 0, std430) readonly buffer TriangleShBuffer {
    vec4 triangle_sh[];
}; 

layout(set = 0, binding = 1, std430) readonly buffer CoarseCellBitmaskBuffer {
    uint coarse_cell_bitmask[];
};

layout(set = 0, binding = 2, std430) readonly buffer CellBitmaskBuffer {
    uint cell_bitmask[];
};

layout(set = 0, binding = 3, rgba16f) uniform image3D voxels;

layout(push_constant) uniform Constants {
    uint num_triangles;
    uint padding1;
    uint padding2;
    uint padding3;
    uint padding4;
    uint padding5;
    uint padding6;
    uint padding7;
};

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#define UINTS_PER_BIN (32768 / 32)
#define COARSE_UINTS_PER_BIN (UINTS_PER_BIN / 32)

void main() {
    vec4 sh = imageLoad(voxels, ivec3(gl_GlobalInvocationID));

    uint cell_index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 32 + gl_GlobalInvocationID.z * 32 * 32;

    for(uint i = 0; i < COARSE_UINTS_PER_BIN; i++) {
        uint coarse_bitmask = coarse_cell_bitmask[cell_index * COARSE_UINTS_PER_BIN + i];

        while(coarse_bitmask > 0) {
            int coarse_bit = findLSB(coarse_bitmask);
            coarse_bitmask &= ~uint(1 << coarse_bit);

            uint fine_mask_index = i * 32 + coarse_bit;
            uint bitmask = cell_bitmask[cell_index * UINTS_PER_BIN + fine_mask_index];
            while(bitmask > 0) {
                int fine_bit = findLSB(bitmask);
                bitmask &= ~uint(1 << fine_bit);
                
                uint triangle_index = fine_mask_index * 32 + fine_bit;
                sh += triangle_sh[triangle_index];
            }
        }
    }

    float sh_length = length(sh);
    if(sh_length > 0) {
        sh /= sh_length;
    }

    imageStore(voxels, ivec3(gl_GlobalInvocationID), sh);
}
