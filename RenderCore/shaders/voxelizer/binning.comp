#version 460

/**
 * Test NDC triangles against the min/max of each bin
 */

#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_ballot : enable

#include "shared/vertex_data.hpp"
#include "shared/triangle.hpp"

layout(set = 0, binding = 0, std430) readonly buffer VertexOutputPositionBuffer {
    Triangle triangles[];
}; 

layout(set = 0, binding = 1, std430) writeonly buffer TriangleBinsBuffer {
    uint bins[];
};

layout(push_constant) uniform Constants {
    uint num_triangles;
    uint padding1;
    uint padding2;
    uint padding3;
    uint padding4;
    uint padding5;
    uint padding6;
    uint padding7;
};

#define NUM_THREADS 96

layout(local_size_x = NUM_THREADS, local_size_y = 1, local_size_z = 1) in;

#define UINTS_PER_BIN (32768 / 32)

// Note: We should plan for a max of 16384 bytes of shared memory
shared uint bin_bits[UINTS_PER_BIN];

bool is_triangle_in_bin(Triangle triangle, vec3 voxel_min, vec3 voxel_max) {
    // Adapted from https://developer.nvidia.com/content/basics-gpu-voxelization

    vec3 aabb_max = max(triangle.v0, max(triangle.v1, triangle.v2));
    vec3 aabb_min = min(triangle.v0, min(triangle.v1, triangle.v2));

    // If the triangle's AABB doesn't overlap the bin's AABB, return false
    if(all(greaterThan(aabb_min, voxel_max)) || all(lessThan(aabb_max, voxel_min))) {
        return false;
    }

    vec3 voxelCenter = (voxel_min + voxel_max) * 0.5f;
    float voxelExtentH = voxel_max.x - voxel_min.x;

    //calculate edge vectors in voxel coordinate space
    vec3 e0 = triangle.v1 - triangle.v0;
    vec3 e1 = triangle.v2 - triangle.v1;
    vec3 e2 = triangle.v0 - triangle.v2;
    vec3 planeNormal = cross(e0, e1);

    // for testing in XY plane projection
    {
        float isFront = -sign(planeNormal.z);

        vec2 eNrm[3];
        eNrm[0] = vec2(e0.y, -e0.x) * isFront;
        eNrm[1] = vec2(e1.y, -e1.x) * isFront;
        eNrm[2] = vec2(e2.y, -e2.x) * isFront;

        vec2      an[3];
        an[0] = abs(eNrm[0]);
        an[1] = abs(eNrm[1]);
        an[2] = abs(eNrm[2]);

        // calculate signed distance offset from a voxel center

        // to the voxel vertex which has maximum signed

        // distance value.
        vec3      eOfs;
        eOfs.x = (an[0].x + an[0].y) * voxelExtentH;
        eOfs.y = (an[1].x + an[1].y) * voxelExtentH;
        eOfs.z = (an[2].x + an[2].y) * voxelExtentH;

        // calculate signed distance of each edges.
        vec3      ef;
        ef.x = eOfs.x - dot(triangle.v0.xy - voxelCenter.xy , eNrm[0]);
        ef.y = eOfs.y - dot(triangle.v1.xy - voxelCenter.xy , eNrm[1]);
        ef.z = eOfs.z - dot(triangle.v2.xy - voxelCenter.xy , eNrm[2]);

        // test is passed if all of signed distances are positive.
        if (ef.x < 0 || ef.y < 0 || ef.z < 0) {
            return false;
        }
    }
    // for testing in YZ plane projection
    {
        float isFront = -sign(planeNormal.x);

        vec2 eNrm[3];
        eNrm[0] = vec2(e0.z, -e0.y) * isFront;
        eNrm[1] = vec2(e1.z, -e1.y) * isFront;
        eNrm[2] = vec2(e2.z, -e2.y) * isFront;

        vec2      an[3];
        an[0] = abs(eNrm[0]);
        an[1] = abs(eNrm[1]);
        an[2] = abs(eNrm[2]);

        // calculate signed distance offset from a voxel center

        // to the voxel vertex which has maximum signed

        // distance value.
        vec3      eOfs;
        eOfs.x = (an[0].x + an[0].y) * voxelExtentH;
        eOfs.y = (an[1].x + an[1].y) * voxelExtentH;
        eOfs.z = (an[2].x + an[2].y) * voxelExtentH;

        // calculate signed distance of each edges.
        vec3      ef;
        ef.x = eOfs.x - dot(triangle.v0.yz - voxelCenter.yz , eNrm[0]);
        ef.y = eOfs.y - dot(triangle.v1.yz - voxelCenter.yz , eNrm[1]);
        ef.z = eOfs.z - dot(triangle.v2.yz - voxelCenter.yz , eNrm[2]);

        // test is passed if all of signed distances are positive.
        if (ef.x < 0 || ef.y < 0 || ef.z < 0) {
            return false;
        }
    }
    // for testing in XZ plane projection
    {
        float isFront = -sign(planeNormal.y);

        vec2 eNrm[3];
        eNrm[0] = vec2(e0.z, -e0.x) * isFront;
        eNrm[1] = vec2(e1.z, -e1.x) * isFront;
        eNrm[2] = vec2(e2.z, -e2.x) * isFront;

        vec2      an[3];
        an[0] = abs(eNrm[0]);
        an[1] = abs(eNrm[1]);
        an[2] = abs(eNrm[2]);

        // calculate signed distance offset from a voxel center

        // to the voxel vertex which has maximum signed

        // distance value.
        vec3      eOfs;
        eOfs.x = (an[0].x + an[0].y) * voxelExtentH;
        eOfs.y = (an[1].x + an[1].y) * voxelExtentH;
        eOfs.z = (an[2].x + an[2].y) * voxelExtentH;

        // calculate signed distance of each edges.
        vec3      ef;
        ef.x = eOfs.x - dot(triangle.v0.xz - voxelCenter.xz , eNrm[0]);
        ef.y = eOfs.y - dot(triangle.v1.xz - voxelCenter.xz , eNrm[1]);
        ef.z = eOfs.z - dot(triangle.v2.xz - voxelCenter.xz , eNrm[2]);

        // test is passed if all of signed distances are positive.
        if (ef.x < 0 || ef.y < 0 || ef.z < 0) {
            return false;
        }
    }

    // Otherwise return true
    return true;
}

void main() {
    // Setup phase - set 1/NUM_THREADS of the bin bits to 0

    uint local_index = gl_SubgroupInvocationID + gl_SubgroupID * gl_SubgroupSize;
    uint uints_per_thread = UINTS_PER_BIN / NUM_THREADS;
    uint first_index = local_index * uints_per_thread;
    for(uint i = first_index; i < first_index + uints_per_thread; i++) {
        bin_bits[i] = 0;
    }
   
    memoryBarrierShared();
    barrier();

    // Each bin is 4x4x4 pixels
    uvec3 bin_idx = gl_WorkGroupID;
    // 4x4x4 bins in a 32x32x32 image - 8 bins in all directions
    vec3 bin_min = vec3(bin_idx) / 8.f;
    vec3 bin_max = bin_min + (1.f / 8.f);

    for(uint triangle_base_idx = 0; triangle_base_idx < num_triangles + NUM_THREADS; triangle_base_idx += NUM_THREADS) {
        uint triangle_idx = triangle_base_idx + local_index;
        if(triangle_idx > num_triangles) {
            continue;
        }

        Triangle triangle = triangles[triangle_idx];

        bool in_bin = is_triangle_in_bin(triangle, bin_min, bin_max);
        uint in_bin_mask = subgroupBallot(in_bin).x;

        uint int_idx = triangle_idx / 32;

        if(subgroupElect()) {
            if(gl_SubgroupSize == 16) {
                // Mali
                if(gl_SubgroupInvocationID % 2 == 1) {
                    in_bin_mask = in_bin_mask << 16;
                }
                atomicOr(bin_bits[int_idx], in_bin_mask);

            } else if(gl_SubgroupSize == 32) {
                // Nvidia
                bin_bits[int_idx] = in_bin_mask;
            }
            // TODO: Support a subgroup size of 64 for AyyyyyMD
        }
    }

    memoryBarrierShared();

    // Now that the bins are in shared memory, each thread can push 1/NUM_THREADS of them to the bin buffer

    uint bin_range_start = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;

    for(uint i = first_index; i < first_index + uints_per_thread; i++) {
        bins[bin_range_start + i] = bin_bits[i];
    }
}
