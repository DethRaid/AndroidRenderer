#version 460

#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "shared/vpl.hpp"
#include "shared/lpv.hpp"
#include "common/spherical_harmonics.glsl"

/**
 * Adds lights to the LPV
 */

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, std430) readonly buffer VplListBuffer {
    PackedVPL vpls[];
};

layout(set = 0, binding = 1, std430) readonly uniform CascadeDataBuffer {
    LPVCascadeMatrices cascade_matrices[4];
};

layout(set = 0, binding = 2, std430) readonly buffer LightLinkedListBuffer {
    // Linked list of lights! The X is the light's index, the Y is the index of the next element in
    // the linked list
    uvec2 light_linked_list[];
};

layout(set = 0, binding = 3, std430) readonly buffer LightListBuffer {
// index of the head of each cell's light list. Starts at 0xFFFFFFFF, set to a real value if needed
    uint light_list_head[];
};

layout(set = 0, binding = 4, rgba16f) uniform image3D lpv_red;
layout(set = 0, binding = 5, rgba16f) uniform image3D lpv_green;
layout(set = 0, binding = 6, rgba16f) uniform image3D lpv_blue;

layout(push_constant) uniform Constants {
    int cascade_index;
    uint padding1;
    uint padding2;
    uint padding3;
    uint padding4;
    uint padding5;
    uint padding6;
    uint padding7;
} push_constants;

VPL unpack_vpl(PackedVPL packed_vpl) {
    VPL vpl;

    vpl.position.xy = unpackHalf2x16(packed_vpl.data.x);
    vpl.position.z = unpackHalf2x16(packed_vpl.data.y).x;
    vpl.color = unpackUnorm4x8(packed_vpl.data.z).rgb;
    vpl.normal = normalize(unpackSnorm4x8(packed_vpl.data.w).xyz);

    return vpl;
}

void main() {
    ivec3 texel = ivec3(gl_GlobalInvocationID);
    texel.x += push_constants.cascade_index * 32;

    vec4 lpv_red_sh = imageLoad(lpv_red, texel);
    vec4 lpv_green_sh = imageLoad(lpv_green, texel);
    vec4 lpv_blue_sh = imageLoad(lpv_blue, texel);

    uint global_invocation_index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 32 + gl_GlobalInvocationID.z * 32 * 32;
    uint next_light = light_list_head[global_invocation_index];
    while(next_light != 0xFFFFFFFF) {
        uvec2 light_index_and_next = light_linked_list[next_light];

        uint light_index = light_index_and_next.x;
        next_light = light_index_and_next.y;

        PackedVPL packed_vpl = vpls[light_index];
        VPL vpl = unpack_vpl(packed_vpl);
        vpl.color *= (32 * 32) / (1024 * 1024);

        if(length(vpl.normal) > 0) {
            lpv_red_sh += sh_project_cone(vpl.normal * vpl.color.r);
            lpv_green_sh += sh_project_cone(vpl.normal * vpl.color.g);
            lpv_blue_sh += sh_project_cone(vpl.normal * vpl.color.b);   
        }
    }

    imageStore(lpv_red, texel, lpv_red_sh);
    imageStore(lpv_green, texel, lpv_green_sh);
    imageStore(lpv_blue, texel, lpv_blue_sh);
}
