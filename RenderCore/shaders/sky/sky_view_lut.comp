// Included first because life is hard
// Don't worry about it
// It's fine
// It's FINE
SamplerState bilinear_sampler : register(s1);

#include "sky/common.hlsli"
#include "shared_structs.hpp"

// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),
// but the latitude/altitude is non-linear to get more resolution near the horizon.

static const int numScatteringSteps = 32;

struct Constants
{
    uint frame_constants_buffer_idx;
    uint transmittance_lut_idx;
    uint multiscattering_lut_idx;
    uint sky_view_lut_idx;
} constants;

float3 raymarchScattering(float3 pos, float3 rayDir, float3 sunDir, float tMax, float numSteps, Texture2D<float4> transmittance_lut, Texture2D<float4> multiscattering_lut)
{
    float cosTheta = dot(rayDir, sunDir);
    
    float miePhaseValue = getMiePhase(cosTheta);
    float rayleighPhaseValue = getRayleighPhase(-cosTheta);
    
    float3 lum = 0.0;
    float3 transmittance = 1.0;
    float t = 0.0;
    for (float i = 0.0; i < numSteps; i += 1.0)
    {
        float newT = ((i + 0.3) / numSteps) * tMax;
        float dt = newT - t;
        t = newT;
        
        float3 newPos = pos + t * rayDir;
        
        float3 rayleighScattering, extinction;
        float mieScattering;
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);
        
        float3 sampleTransmittance = exp(-dt * extinction);

        float3 sunTransmittance = getValFromTLUT(transmittance_lut, newPos, sunDir);
        float3 psiMS = getValFromMultiScattLUT(multiscattering_lut, newPos, sunDir);
        
        float3 rayleighInScattering = rayleighScattering * (rayleighPhaseValue * sunTransmittance + psiMS);
        float3 mieInScattering = mieScattering * (miePhaseValue * sunTransmittance + psiMS);
        float3 inScattering = (rayleighInScattering + mieInScattering);

        // Integrated scattering within path segment.
        float3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

        lum += scatteringIntegral * transmittance;
        
        transmittance *= sampleTransmittance;
    }
    return lum;
}

[numthreads(8, 8, 1)]
void main(uint3 thread_id : SV_DispatchThreadID) {
    
    RWTexture2D<float4> sky_view_lut = ResourceDescriptorHeap[constants.sky_view_lut_idx];
    float2 lut_dimensions;
    sky_view_lut.GetDimensions(lut_dimensions.x, lut_dimensions.y);

    if (thread_id.x > lut_dimensions.x || thread_id.y > lut_dimensions.y)
    {
        return;
    }
    
    float u = (float) thread_id.x / lut_dimensions.x;
    float v = (float) thread_id.y / lut_dimensions.y;
    
    float azimuthAngle = (u - 0.5) * 2.0 * PI;
    // Non-linear mapping of altitude. See Section 5.3 of the paper.
    float adjV;
    if (v < 0.5)
    {
        float coord = 1.0 - 2.0 * v;
        adjV = -coord * coord;
    }
    else
    {
        float coord = v * 2.0 - 1.0;
        adjV = coord * coord;
    }
    
    float height = length(viewPos);
    float3 up = viewPos / height;
    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5 * PI;
    float altitudeAngle = adjV * 0.5 * PI - horizonAngle;
    
    float cosAltitude = cos(altitudeAngle);
    float3 rayDir = float3(cosAltitude * sin(azimuthAngle), sin(altitudeAngle), -cosAltitude * cos(azimuthAngle));
    
    const StructuredBuffer<FrameConstants> frame_data_buffer = ResourceDescriptorHeap[constants.frame_constants_buffer_idx];
    const FrameConstants per_frame_data = frame_data_buffer[0];
    const StructuredBuffer<Light> light_buffer = ResourceDescriptorHeap[per_frame_data.light_buffer_index];
    const Light sun = light_buffer[per_frame_data.sun_index];

    float sunAltitude = (0.5 * PI) - acos(dot(-sun.direction_or_location.xyz, up));
    float3 sunDir = float3(0.0, sin(sunAltitude), -cos(sunAltitude));

    const Texture2D<float4> transmittance_lut = ResourceDescriptorHeap[constants.transmittance_lut_idx];
    const Texture2D<float4> multiscattering_lut = ResourceDescriptorHeap[constants.multiscattering_lut_idx];
    float atmoDist = rayIntersectSphere(viewPos, rayDir, atmosphereRadiusMM);
    float groundDist = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);
    float tMax = (groundDist < 0.0) ? atmoDist : groundDist;
    float3 lum = raymarchScattering(viewPos, rayDir, sunDir, tMax, float(numScatteringSteps), transmittance_lut, multiscattering_lut);

    sky_view_lut[thread_id.xy] = float4(lum, 1.f);
}

